/**
 * RepositoryÂêåÂÄ§ÊÄß„ÉÜ„Çπ„Éà
 * ÂæìÊù•„ÅÆ„ÇØ„É©„Çπ„Éô„Éº„ÇπRepository„Å®Èñ¢Êï∞ÂûãRepository„ÅåÂêå„ÅòÁµêÊûú„ÇíËøî„Åô„Åì„Å®„ÇíÊ§úË®º
 */

import { describe, it, expect, vi, beforeEach } from "vitest";
import { SupabaseBucketListRepository } from "../supabase-bucket-list-repository";
import { createFunctionalBucketListRepository } from "../functional-bucket-list-repository";
import type { SupabaseClient } from "@supabase/supabase-js";
import type { Database } from "~/shared/types/database";
import type {
  BucketItem,
  BucketItemInsert,
  BucketItemUpdate,
  Category,
  UserBucketStats,
  BucketListFilters,
  BucketListSort,
} from "~/features/bucket-list/types";

// „É¢„ÉÉ„ÇØ„Éá„Éº„Çø
const mockBucketItem: BucketItem = {
  id: "test-id",
  profile_id: "user-123",
  title: "„ÉÜ„Çπ„ÉàÈ†ÖÁõÆ",
  description: "„ÉÜ„Çπ„ÉàË™¨Êòé",
  category_id: 1,
  priority: "high",
  status: "not_started",
  is_public: false,
  due_type: "specific_date",
  due_date: "2024-12-31",
  created_at: "2024-01-01T00:00:00.000Z",
  updated_at: "2024-01-01T00:00:00.000Z",
};

const mockCategory: Category = {
  id: 1,
  name: "ÊóÖË°å„ÉªË¶≥ÂÖâ",
  description: "ÊóÖË°å„ÇÑË¶≥ÂÖâ„Å´Èñ¢„Åô„ÇãÈ†ÖÁõÆ",
  color: "#FF6B6B",
  icon: "üó∫Ô∏è",
  created_at: "2024-01-01T00:00:00.000Z",
  updated_at: "2024-01-01T00:00:00.000Z",
};

const mockUserStats: UserBucketStats = {
  profile_id: "user-123",
  total_items: 10,
  completed_items: 3,
  not_started_items: 5,
  in_progress_items: 2,
  completion_rate: 0.3,
  created_at: "2024-01-01T00:00:00.000Z",
  updated_at: "2024-01-01T00:00:00.000Z",
};

const mockInsertData: BucketItemInsert = {
  profile_id: "user-123",
  title: "Êñ∞„Åó„ÅÑÈ†ÖÁõÆ",
  description: "Êñ∞„Åó„ÅÑÈ†ÖÁõÆ„ÅÆË™¨Êòé",
  category_id: 1,
  priority: "medium",
  status: "not_started",
  is_public: false,
  due_type: "this_year",
};

const mockUpdateData: BucketItemUpdate = {
  title: "Êõ¥Êñ∞„Åï„Çå„ÅüÈ†ÖÁõÆ",
  description: "Êõ¥Êñ∞„Åï„Çå„ÅüË™¨Êòé",
  priority: "low",
  status: "completed",
};

describe("RepositoryÂêåÂÄ§ÊÄß„ÉÜ„Çπ„Éà", () => {
  let classBasedRepository: SupabaseBucketListRepository;
  let functionalRepository: ReturnType<typeof createFunctionalBucketListRepository>;
  let mockSupabase: SupabaseClient<Database>;
  let mockFrom: any;
  let mockSelect: any;
  let mockInsert: any;
  let mockUpdate: any;
  let mockDelete: any;
  let mockEq: any;
  let mockOrder: any;
  let mockSingle: any;
  let mockOr: any;

  beforeEach(() => {
    // ÂÖ±ÈÄö„ÅÆ„É¢„ÉÉ„ÇØË®≠ÂÆö
    mockSingle = vi.fn();
    mockOr = vi.fn();
    mockOrder = vi.fn(() => ({ data: [], error: null }));
    mockEq = vi.fn(() => ({
      select: mockSelect,
      single: mockSingle,
      or: mockOr,
      order: mockOrder,
    }));
    mockSelect = vi.fn(() => ({
      eq: mockEq,
      single: mockSingle,
      or: mockOr,
      order: mockOrder,
    }));
    mockInsert = vi.fn(() => ({
      select: mockSelect,
      single: mockSingle,
    }));
    mockUpdate = vi.fn(() => ({
      eq: mockEq,
      select: mockSelect,
      single: mockSingle,
    }));
    mockDelete = vi.fn(() => ({
      eq: mockEq,
    }));
    mockFrom = vi.fn(() => ({
      select: mockSelect,
      insert: mockInsert,
      update: mockUpdate,
      delete: mockDelete,
    }));

    mockSupabase = {
      from: mockFrom,
    } as any;

    // ‰∏°Êñπ„ÅÆRepository„ÇíÂêå„Åò„É¢„ÉÉ„ÇØSupabase„ÇØ„É©„Ç§„Ç¢„É≥„Éà„ÅßÂàùÊúüÂåñ
    classBasedRepository = new SupabaseBucketListRepository(mockSupabase);
    functionalRepository = createFunctionalBucketListRepository(mockSupabase);
  });

  describe("findAllÊìç‰Ωú„ÅÆÂêåÂÄ§ÊÄß", () => {
    it("ÊàêÂäüÊôÇ„Å´‰∏°Êñπ„ÅÆRepository„ÅåÂêå„ÅòÁµêÊûú„ÇíËøî„Åô„Åì„Å®", async () => {
      const mockData = [mockBucketItem];
      mockOrder.mockResolvedValue({ data: mockData, error: null });

      const classBasedResult = await classBasedRepository.findAll();
      const functionalResult = await functionalRepository.findAll();

      expect(classBasedResult).toEqual(mockData);
      expect(functionalResult.success).toBe(true);
      if (functionalResult.success) {
        expect(functionalResult.data).toEqual(classBasedResult);
      }
    });

    it("„Éï„Ç£„É´„Çø„ÉºÈÅ©Áî®ÊôÇ„Å´‰∏°Êñπ„ÅÆRepository„ÅåÂêå„Åò„ÇØ„Ç®„É™„ÇíÂÆüË°å„Åô„Çã„Åì„Å®", async () => {
      const mockData = [mockBucketItem];
      mockOrder.mockResolvedValue({ data: mockData, error: null });

      const filters: BucketListFilters = {
        profile_id: "user-123",
        category_id: 1,
        priority: "high",
        status: "not_started",
        is_public: false,
        search: "„ÉÜ„Çπ„Éà",
      };

      // „É¢„ÉÉ„ÇØ„Çí„É™„Çª„ÉÉ„Éà
      vi.clearAllMocks();

      await classBasedRepository.findAll(filters);
      const classBasedCalls = {
        fromCalls: mockFrom.mock.calls.length,
        selectCalls: mockSelect.mock.calls.length,
        eqCalls: mockEq.mock.calls.length,
        orCalls: mockOr.mock.calls.length,
        orderCalls: mockOrder.mock.calls.length,
      };

      // „É¢„ÉÉ„ÇØ„Çí„É™„Çª„ÉÉ„Éà
      vi.clearAllMocks();

      await functionalRepository.findAll(filters);
      const functionalCalls = {
        fromCalls: mockFrom.mock.calls.length,
        selectCalls: mockSelect.mock.calls.length,
        eqCalls: mockEq.mock.calls.length,
        orCalls: mockOr.mock.calls.length,
        orderCalls: mockOrder.mock.calls.length,
      };

      // Âêå„ÅòÊï∞„ÅÆ„É°„ÇΩ„ÉÉ„ÉâÂëº„Å≥Âá∫„Åó„ÅåË°å„Çè„Çå„Çã„Åì„Å®„ÇíÁ¢∫Ë™ç
      expect(functionalCalls).toEqual(classBasedCalls);
    });

    it("„Ç®„É©„ÉºÊôÇ„ÅÆÂá¶ÁêÜ„ÅåÈÅ©Âàá„Å´Ë°å„Çè„Çå„Çã„Åì„Å®", async () => {
      const mockError = { message: "Database error", code: "PGRST301" };
      mockOrder.mockResolvedValue({ data: null, error: mockError });

      // „ÇØ„É©„Çπ„Éô„Éº„Çπ„ÅØ„Ç®„É©„Éº„ÇíÊäï„Åí„Çã
      await expect(classBasedRepository.findAll()).rejects.toThrow();

      // Èñ¢Êï∞Âûã„ÅØResultÂûã„Åß„Ç®„É©„Éº„ÇíËøî„Åô
      const functionalResult = await functionalRepository.findAll();
      expect(functionalResult.success).toBe(false);
      if (!functionalResult.success) {
        expect(functionalResult.error.message).toContain("Database error");
      }
    });
  });

  describe("findByIdÊìç‰Ωú„ÅÆÂêåÂÄ§ÊÄß", () => {
    it("Â≠òÂú®„Åô„ÇãID„Åß‰∏°Êñπ„ÅÆRepository„ÅåÂêå„ÅòÁµêÊûú„ÇíËøî„Åô„Åì„Å®", async () => {
      mockSingle.mockResolvedValue({ data: mockBucketItem, error: null });

      const classBasedResult = await classBasedRepository.findById("test-id");
      const functionalResult = await functionalRepository.findById("test-id");

      expect(classBasedResult).toEqual(mockBucketItem);
      expect(functionalResult.success).toBe(true);
      if (functionalResult.success) {
        expect(functionalResult.data).toEqual(classBasedResult);
      }
    });

    it("Â≠òÂú®„Åó„Å™„ÅÑID„Åß‰∏°Êñπ„ÅÆRepository„Åånull„ÇíËøî„Åô„Åì„Å®", async () => {
      const mockError = { message: "No rows found", code: "PGRST116" };
      mockSingle.mockResolvedValue({ data: null, error: mockError });

      const classBasedResult = await classBasedRepository.findById("non-existent");
      const functionalResult = await functionalRepository.findById("non-existent");

      expect(classBasedResult).toBeNull();
      expect(functionalResult.success).toBe(true);
      if (functionalResult.success) {
        expect(functionalResult.data).toEqual(classBasedResult);
      }
    });
  });

  describe("createÊìç‰Ωú„ÅÆÂêåÂÄ§ÊÄß", () => {
    it("‰ΩúÊàêÊôÇ„Å´‰∏°Êñπ„ÅÆRepository„ÅåÂêå„ÅòÁµêÊûú„ÇíËøî„Åô„Åì„Å®", async () => {
      const mockCreatedItem = { ...mockBucketItem, ...mockInsertData };
      mockSingle.mockResolvedValue({ data: mockCreatedItem, error: null });

      const classBasedResult = await classBasedRepository.create(mockInsertData);
      const functionalResult = await functionalRepository.create(mockInsertData);

      expect(classBasedResult).toEqual(mockCreatedItem);
      expect(functionalResult.success).toBe(true);
      if (functionalResult.success) {
        expect(functionalResult.data).toEqual(classBasedResult);
      }

      // ‰∏°Êñπ„Å®„ÇÇÂêå„Åò„Éá„Éº„Çø„Åß insert „ÅåÂëº„Å∞„Çå„Çã„Åì„Å®„ÇíÁ¢∫Ë™ç
      expect(mockInsert).toHaveBeenCalledTimes(2);
      const [firstCall, secondCall] = mockInsert.mock.calls;
      expect(firstCall[0]).toEqual(secondCall[0]);
    });
  });

  describe("updateÊìç‰Ωú„ÅÆÂêåÂÄ§ÊÄß", () => {
    it("Êõ¥Êñ∞ÊôÇ„Å´‰∏°Êñπ„ÅÆRepository„ÅåÂêå„ÅòÁµêÊûú„ÇíËøî„Åô„Åì„Å®", async () => {
      const mockUpdatedItem = { ...mockBucketItem, ...mockUpdateData };
      mockSingle.mockResolvedValue({ data: mockUpdatedItem, error: null });

      const classBasedResult = await classBasedRepository.update("test-id", mockUpdateData);
      const functionalResult = await functionalRepository.update("test-id", mockUpdateData);

      expect(classBasedResult).toEqual(mockUpdatedItem);
      expect(functionalResult.success).toBe(true);
      if (functionalResult.success) {
        expect(functionalResult.data).toEqual(classBasedResult);
      }

      // ‰∏°Êñπ„Å®„ÇÇÂêå„Åò„Éá„Éº„Çø„Åß update „ÅåÂëº„Å∞„Çå„Çã„Åì„Å®„ÇíÁ¢∫Ë™ç
      expect(mockUpdate).toHaveBeenCalledTimes(2);
      const [firstCall, secondCall] = mockUpdate.mock.calls;
      expect(firstCall[0]).toEqual(secondCall[0]);
    });
  });

  describe("deleteÊìç‰Ωú„ÅÆÂêåÂÄ§ÊÄß", () => {
    it("ÂâäÈô§ÊôÇ„Å´‰∏°Êñπ„ÅÆRepository„ÅåÂêå„ÅòÂãï‰Ωú„Çí„Åô„Çã„Åì„Å®", async () => {
      mockEq.mockResolvedValue({ data: null, error: null });

      const classBasedResult = await classBasedRepository.delete("test-id");
      const functionalResult = await functionalRepository.delete("test-id");

      expect(classBasedResult).toBeUndefined();
      expect(functionalResult.success).toBe(true);
      if (functionalResult.success) {
        expect(functionalResult.data).toBeUndefined();
      }

      // ‰∏°Êñπ„Å®„ÇÇÂêå„Åò ID „Åß delete „ÅåÂëº„Å∞„Çå„Çã„Åì„Å®„ÇíÁ¢∫Ë™ç
      expect(mockDelete).toHaveBeenCalledTimes(2);
      expect(mockEq).toHaveBeenCalledWith("id", "test-id");
    });
  });

  describe("findAllCategoriesÊìç‰Ωú„ÅÆÂêåÂÄ§ÊÄß", () => {
    it("„Ç´„ÉÜ„Ç¥„É™ÂèñÂæó„Åß‰∏°Êñπ„ÅÆRepository„ÅåÂêå„ÅòÁµêÊûú„ÇíËøî„Åô„Åì„Å®", async () => {
      const mockCategories = [mockCategory];
      mockOrder.mockResolvedValue({ data: mockCategories, error: null });

      const classBasedResult = await classBasedRepository.findAllCategories();
      const functionalResult = await functionalRepository.findAllCategories();

      expect(classBasedResult).toEqual(mockCategories);
      expect(functionalResult.success).toBe(true);
      if (functionalResult.success) {
        expect(functionalResult.data).toEqual(classBasedResult);
      }
    });
  });

  describe("getUserStatsÊìç‰Ωú„ÅÆÂêåÂÄ§ÊÄß", () => {
    it("„É¶„Éº„Ç∂„ÉºÁµ±Ë®àÂèñÂæó„Åß‰∏°Êñπ„ÅÆRepository„ÅåÂêå„ÅòÁµêÊûú„ÇíËøî„Åô„Åì„Å®", async () => {
      mockSingle.mockResolvedValue({ data: mockUserStats, error: null });

      const classBasedResult = await classBasedRepository.getUserStats("user-123");
      const functionalResult = await functionalRepository.getUserStats("user-123");

      expect(classBasedResult).toEqual(mockUserStats);
      expect(functionalResult.success).toBe(true);
      if (functionalResult.success) {
        expect(functionalResult.data).toEqual(classBasedResult);
      }
    });

    it("Â≠òÂú®„Åó„Å™„ÅÑ„É¶„Éº„Ç∂„Éº„Åßnull„ÇíËøî„Åô„Åì„Å®", async () => {
      const mockError = { message: "No rows found", code: "PGRST116" };
      mockSingle.mockResolvedValue({ data: null, error: mockError });

      const classBasedResult = await classBasedRepository.getUserStats("non-existent");
      const functionalResult = await functionalRepository.getUserStats("non-existent");

      expect(classBasedResult).toBeNull();
      expect(functionalResult.success).toBe(true);
      if (functionalResult.success) {
        expect(functionalResult.data).toEqual(classBasedResult);
      }
    });
  });

  describe("Ë§áÈõë„Å™„Ç∑„Éä„É™„Ç™„ÅÆÂêåÂÄ§ÊÄß", () => {
    it("Ë§áÊï∞„ÅÆ„Éï„Ç£„É´„Çø„Éº„Å®„ÇΩ„Éº„Éà„ÇíÈÅ©Áî®„Åó„ÅüÂ†¥Âêà„ÅÆÂêåÂÄ§ÊÄß", async () => {
      const mockData = [mockBucketItem];
      mockOrder.mockResolvedValue({ data: mockData, error: null });

      const filters: BucketListFilters = {
        profile_id: "user-123",
        category_id: 1,
        priority: "high",
        status: "not_started",
        is_public: false,
        search: "„ÉÜ„Çπ„ÉàÊ§úÁ¥¢",
      };

      const sort: BucketListSort = {
        field: "created_at",
        direction: "desc",
      };

      const classBasedResult = await classBasedRepository.findByProfileId("user-123", filters, sort);
      const functionalResult = await functionalRepository.findByProfileId("user-123", filters, sort);

      expect(classBasedResult).toEqual(mockData);
      expect(functionalResult.success).toBe(true);
      if (functionalResult.success) {
        expect(functionalResult.data).toEqual(classBasedResult);
      }
    });

    it("„Ç®„É©„ÉºÂá¶ÁêÜ„ÅÆ‰∏ÄË≤´ÊÄßÁ¢∫Ë™ç", async () => {
      const errorScenarios = [
        { code: "PGRST301", message: "Permission denied" },
        { code: "PGRST400", message: "Bad request" },
        { code: "PGRST500", message: "Internal server error" },
      ];

      for (const scenario of errorScenarios) {
        mockOrder.mockResolvedValue({ data: null, error: scenario });

        // „ÇØ„É©„Çπ„Éô„Éº„Çπ„ÅØ‰æãÂ§ñ„ÇíÊäï„Åí„Çã
        await expect(classBasedRepository.findAll()).rejects.toThrow();

        // Èñ¢Êï∞Âûã„ÅØResultÂûã„Åß„Ç®„É©„Éº„ÇíËøî„Åô
        const functionalResult = await functionalRepository.findAll();
        expect(functionalResult.success).toBe(false);
        if (!functionalResult.success) {
          expect(functionalResult.error.message).toContain(scenario.message);
        }
      }
    });
  });

  describe("„Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÁâπÊÄß„ÅÆÊØîËºÉ", () => {
    it("Âêå„ÅòÊï∞„ÅÆSupabase„ÇØ„É©„Ç§„Ç¢„É≥„ÉàÂëº„Å≥Âá∫„Åó„ÅåË°å„Çè„Çå„Çã„Åì„Å®", async () => {
      const mockData = [mockBucketItem];
      mockOrder.mockResolvedValue({ data: mockData, error: null });

      // „ÇØ„É©„Çπ„Éô„Éº„Çπ„ÅÆÂëº„Å≥Âá∫„ÅóÂõûÊï∞„Ç´„Ç¶„É≥„Éà
      vi.clearAllMocks();
      await classBasedRepository.findAll();
      const classBasedCallCount = mockFrom.mock.calls.length;

      // Èñ¢Êï∞Âûã„ÅÆÂëº„Å≥Âá∫„ÅóÂõûÊï∞„Ç´„Ç¶„É≥„Éà
      vi.clearAllMocks();
      await functionalRepository.findAll();
      const functionalCallCount = mockFrom.mock.calls.length;

      expect(functionalCallCount).toBe(classBasedCallCount);
    });

    it("Âêå‰∏Ä„ÅÆÂºïÊï∞„ÅßÂêå‰∏Ä„ÅÆSupabase„É°„ÇΩ„ÉÉ„Éâ„ÅåÂëº„Å∞„Çå„Çã„Åì„Å®", async () => {
      const mockData = [mockBucketItem];
      mockOrder.mockResolvedValue({ data: mockData, error: null });

      const testId = "test-id";

      // ‰∏°Êñπ„ÅÆRepository„ÅßÂêå„ÅòÊìç‰Ωú„ÇíÂÆüË°å
      vi.clearAllMocks();
      await classBasedRepository.findById(testId);
      const classBasedFromCall = mockFrom.mock.calls[0];
      const classBasedEqCall = mockEq.mock.calls[0];

      vi.clearAllMocks();
      await functionalRepository.findById(testId);
      const functionalFromCall = mockFrom.mock.calls[0];
      const functionalEqCall = mockEq.mock.calls[0];

      // Âêå„Åò„ÉÜ„Éº„Éñ„É´Âêç„Åß from „ÅåÂëº„Å∞„Çå„Çã„Åì„Å®„ÇíÁ¢∫Ë™ç
      expect(functionalFromCall).toEqual(classBasedFromCall);
      // Âêå„ÅòÂºïÊï∞„Åß eq „ÅåÂëº„Å∞„Çå„Çã„Åì„Å®„ÇíÁ¢∫Ë™ç
      expect(functionalEqCall).toEqual(classBasedEqCall);
    });
  });
});